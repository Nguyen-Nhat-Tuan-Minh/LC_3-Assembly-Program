; LC-3 Assembly Program: Division with User Input
; Author: Minh Nguyen Nhat Tuan
; Date: 13/12/2023

; Description:
; This LC-3 assembly program demonstrates a simple division operation where the user
; is prompted to input the length of digits for both the dividend and divisor. After
; obtaining the lengths, the program then prompts the user to enter the actual values
; for the dividend and divisor. Subsequently, it performs the division operation,
; computes the quotient and remainder, and outputs the results to the monitor.

; How to Use:
; 1. Run the program on an LC-3 simulator.
; 2. When prompted, enter the length of digits for both the dividend and divisor.
; 3. Input the actual values for the dividend and divisor.
; 4. The program will calculate the quotient and remainder.
; 5. The results will be displayed on the monitor.

.ORIG x3000

AGAIN

LEA R0, PROMPT1
PUTS
JSR INPUT
ST R3, DIVIDEND
LD R0, NEWLINE
OUT
LEA R0, PROMPT2
PUTS
JSR INPUT
ST R3, DIVISOR
ADD R0, R3, #0
BRz DIV_BY_ZERO

JSR DIVISION
LD R0, NEWLINE
OUT

LEA R0, QUOTIENT_MSG
PUTS
LD R5, QUOTIENT
JSR DISPLAY ; DISPLAY QUOTIENT
LD R0, NEWLINE
OUT
LEA R0, REMAINDER_MSG
PUTS
LD R5, REMAINDER
JSR DISPLAY ; DISPLAY REMAINDER

LD R0, NEWLINE
OUT
LD R0, NEWLINE
OUT
BR AGAIN

DIV_BY_ZERO
LD R0, NEWLINE
OUT
LEA R0, DIVZ
PUTS
BR FINISH

ERROR
LD R0, NEWLINE
OUT
LEA R0, ERROR_MSG0
PUTS
LD R0, NEWLINE
OUT
LEA R0, ERROR_MSG1
PUTS
LD R0, NEWLINE
OUT

FINISH
HALT

QUOTIENT_MSG .STRINGZ "THE DIVISION QUOTIENT IS: "
REMAINDER_MSG .STRINGZ "THE DIVISION REMAINDER IS: "

; RELEVANT ASCII VALUE
NEWLINE .FILL #10
ASCII .FILL #48
NEGASCII .FILL #-48

LOOKUP
.FILL #0
.FILL #1
.FILL #10
.FILL #100
.FILL #1000
.FILL #10000

SAVER0 .FILL #0
SAVER1 .FILL #0
SAVER2 .FILL #0
SAVER3 .FILL #0
SAVER4 .FILL #0
SAVER5 .FILL #0
SAVER6 .FILL #0
SAVER7 .FILL #0
SAVER7_NEW .FILL #0
DIVIDEND .FILL #0
DIVISOR .FILL #0
QUOTIENT .FILL #0
REMAINDER .FILL #0

; MESSAGE SECTION
PROMPT1 .STRINGZ "ENTER NUMBER OF DIVIDEND DIGIT: "
PROMPT2 .STRINGZ "ENTER NUMBER OF DIVISOR DIGIT: "
PROMPT_NUM_L .STRINGZ "ENTER "
PROMPT_NUM_H .STRINGZ " DIGIT(S) OF NUMBER: "
ERROR_MSG0 .STRINGZ "INVALID NUMBER OF DIGIT!"
ERROR_MSG1 .STRINGZ "DIGIT HAS TO BE 1-5!"
DIVZ .STRINGZ "DIVIDE BY ZERO!"

; NUMBER OF DIGIT STORE IN R4
; INPUT CALL MULTIPLY TO GET FINAL 5-DIGIT NUMBER
INPUT 
ST R7, SAVER7

GETC ; GET NUMBER OF DIGIT (1-5)
OUT
LD R7, NEGASCII
ADD R7, R7, R0
BRz ERROR
ADD R4, R0, #0

LD R0, NEWLINE
OUT

LEA R0, PROMPT_NUM_L
PUTS
ADD R0, R4, #0
OUT
LEA R0, PROMPT_NUM_H
PUTS

LD R5, NEGASCII
ADD R4, R4, R5 ; CONVERT ASCII - BINARY
AND R3, R3, #0 ; INIT R3

INPUT_LOOP
GETC
OUT
ADD R1, R5, R0
JSR MULTIPLY
ADD R4, R4, #-1
BRp INPUT_LOOP
LD R0, NEWLINE
OUT

LD R7, SAVER7
RET

; PASS VALUE IS IN R1 = NUM AND R2 = MULTIPLICAND
; MULTIPLY RESULT STORE IN R3
MULTIPLY
ST R7, SAVER7_NEW

LEA R0, LOOKUP ; R0 = table base
ADD R0, R0, R4 ; add index (R4)
LDR R2, R0, #0 ; load from M[R0] -> R2

MULTLOOP
ADD R3, R3, R1
ADD R2, R2, #-1
BRp MULTLOOP

LD R7, SAVER7_NEW
RET

; PASS VALUE IS IN R1 = DIVIDEND AND R2 = DIVISOR
; QUOTIENT RESULT STORE IN R3, REMAINDER RESULT STORE IN R1
DIVISION
ST R7, SAVER7

AND R3, R3, #0
AND R4, R4, #0
LD R1, DIVIDEND
LD R2, DIVISOR
LD R4, DIVISOR
NOT R2, R2
ADD R2, R2, #1 ; R2 = -DIVISOR

DIV_LOOP
ADD R3, R3, #1
ADD R1, R1, R2
BRzp DIV_LOOP

ADD R3, R3, #-1
ADD R1, R1, R4

ST R1, REMAINDER
ST R3, QUOTIENT

LD R7, SAVER7
RET

; COMPACT DISPLAY SUBROUTINE FOR ELIMINATING LEADING ZERO
OMIT_DISPLAY
AND R6, R6, #0
ADD R6, R6, R4
BRz IS_ZERO
AND R6, R6, #0
BR RETURN

IS_ZERO
AND R6, R6, #0
ADD R6, R6, #1

RETURN
RET

; PASS VALUE LOOKUP_NEG INDEX IN R1
; OFFSET VALUE IN R2
; EACH DIGIT IS DISPLAY FROM HIGH - LOW
DISPLAY
ST R7, DIVSAVER7

; TEN THOUSAND DECIMAL DISPLAY
AND R2, R2, #0
ADD R2, R2, #5
LEA R1, LOOKUP_NEG
ADD R1, R1, R2
LDR R3, R1, #0
AND R4, R4, #0

LOOP_0 ; TEN THOUSAND LOOP
ADD R4, R4, #1
ADD R5, R5, R3 ; R5 = R5 - 10000
BRzp LOOP_0

ADD R4, R4, #-1
JSR OMIT_DISPLAY
ADD R6, R6, #0
BRp PASS_0
JSR SUB_DISPLAY
PASS_0
NOT R3, R3
ADD R3, R3, #1
ADD R5, R5, R3

; THOUSAND DECIMAL DISPLAY
AND R2, R2, #0
ADD R2, R2, #4
LEA R1, LOOKUP_NEG
ADD R1, R1, R2
LDR R3, R1, #0
AND R4, R4, #0

LOOP_1 ; THOUSAND LOOP
ADD R4, R4, #1
ADD R5, R5, R3 ; R5 = R5 - 1000
BRzp LOOP_1

ADD R4, R4, #-1

ADD R6, R6, #0
BRz CONT_0 ; SAMPLE FOR THOUSAND LEADING ZERO
JSR OMIT_DISPLAY
ADD R6, R6, #0
BRp PASS_1

CONT_0
JSR SUB_DISPLAY
PASS_1

NOT R3, R3
ADD R3, R3, #1
ADD R5, R5, R3

; HUNDRED DECIMAL DISPLAY
AND R2, R2, #0
ADD R2, R2, #3
LEA R1, LOOKUP_NEG
ADD R1, R1, R2
LDR R3, R1, #0
AND R4, R4, #0

LOOP_2 ; HUNDRED LOOP
ADD R4, R4, #1
ADD R5, R5, R3 ; R5 = R5 - 100
BRzp LOOP_2

ADD R4, R4, #-1

ADD R6, R6, #0
BRz CONT_1 ; SAMPLE FOR HUNDRED LEADING ZERO
JSR OMIT_DISPLAY
ADD R6, R6, #0
BRp PASS_2

CONT_1
JSR SUB_DISPLAY
PASS_2

NOT R3, R3
ADD R3, R3, #1
ADD R5, R5, R3

; TEN DECIMAL DISPLAY
AND R2, R2, #0
ADD R2, R2, #2
LEA R1, LOOKUP_NEG
ADD R1, R1, R2
LDR R3, R1, #0
AND R4, R4, #0

LOOP_3 ; TEN LOOP
ADD R4, R4, #1
ADD R5, R5, R3 ; R5 = R5 - 10
BRzp LOOP_3

ADD R4, R4, #-1

ADD R6, R6, #0
BRz CONT_2 ; SAMPLE FOR TEN LEADING ZERO
JSR OMIT_DISPLAY
ADD R6, R6, #0
BRp PASS_3

CONT_2
JSR SUB_DISPLAY
PASS_3

NOT R3, R3
ADD R3, R3, #1
ADD R5, R5, R3

; UNIT DECIMAL DISPLAY
AND R2, R2, #0
ADD R2, R2, #1
LEA R1, LOOKUP_NEG
ADD R1, R1, R2
LDR R3, R1, #0
AND R4, R4, #0

LOOP_4 ; UNIT LOOP
ADD R4, R4, #1
ADD R5, R5, R3 ; R5 = R5 - 1
BRzp LOOP_4

ADD R4, R4, #-1
JSR SUB_DISPLAY
NOT R3, R3
ADD R3, R3, #1
ADD R5, R5, R3

LD R7, DIVSAVER7
RET

; DISPLAY SUBROUTINE FOR A SPECIFIC CHARACTER
SUB_DISPLAY
ST R7, DISPR7

LD R0, ASCII_REP
ADD R0, R0, R4
OUT

LD R7, DISPR7
RET

LOOKUP_NEG
.FILL #0
.FILL #-1
.FILL #-10
.FILL #-100
.FILL #-1000
.FILL #-10000

DISPR7 .FILL #0
DIVSAVER7 .FILL #0
ASCII_REP .FILL #48
NEGASCII_REP .FILL #-48

.END
